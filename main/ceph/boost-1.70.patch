diff -aur a/src/rgw/rgw_asio_frontend.cc b/src/rgw/rgw_asio_frontend.cc
--- a/src/rgw/rgw_asio_frontend.cc	2019-12-07 03:42:34.000000000 +1100
+++ b/src/rgw/rgw_asio_frontend.cc	2020-01-08 21:50:11.750738626 +1100
@@ -160,7 +160,7 @@
                                   rgw::io::add_conlen_controlling(
                                     &real_client))));
       RGWRestfulIO client(cct, &real_client_io);
-      auto y = optional_yield{socket.get_io_context(), yield};
+      auto y = optional_yield{context, yield};
       process_request(env.store, env.rest, &req, env.uri_prefix,
                       *env.auth_registry, &client, env.olog, y, scheduler);
     }
Only in b/src/rgw: rgw_asio_frontend.cc.orig
diff -aur a/src/rgw/rgw_dmclock_async_scheduler.h b/src/rgw/rgw_dmclock_async_scheduler.h
--- a/src/rgw/rgw_dmclock_async_scheduler.h	2019-12-07 03:42:34.000000000 +1100
+++ b/src/rgw/rgw_dmclock_async_scheduler.h	2020-01-08 21:50:11.750738626 +1100
@@ -82,7 +82,12 @@
   using Completion = async::Completion<Signature, async::AsBase<Request>>;
 
   using Clock = ceph::coarse_real_clock;
+#if BOOST_VERSION < 107000
   using Timer = boost::asio::basic_waitable_timer<Clock>;
+#else
+  using Timer = boost::asio::basic_waitable_timer<Clock,
+        boost::asio::wait_traits<Clock>, executor_type>;
+#endif
   Timer timer; //< timer for the next scheduled request
 
   CephContext *const cct;
diff -aur a/src/rgw/rgw_reshard.h b/src/rgw/rgw_reshard.h
--- a/src/rgw/rgw_reshard.h	2019-12-07 03:42:34.000000000 +1100
+++ b/src/rgw/rgw_reshard.h	2020-01-08 21:50:11.750738626 +1100
@@ -183,7 +183,14 @@
   ceph::condition_variable cond;
 
   struct Waiter : boost::intrusive::list_base_hook<> {
-    boost::asio::basic_waitable_timer<Clock> timer;
+#if BOOST_VERSION < 107000
+    using Timer = boost::asio::basic_waitable_timer<Clock>;
+#else
+    using Executor = boost::asio::io_context::executor_type;
+    using Timer = boost::asio::basic_waitable_timer<Clock,
+          boost::asio::wait_traits<Clock>, Executor>;
+#endif
+    Timer timer;
     explicit Waiter(boost::asio::io_context& ioc) : timer(ioc) {}
   };
   boost::intrusive::list<Waiter> waiters;
